// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: turnos.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const cancelTurno = `-- name: CancelTurno :exec
UPDATE turnos
SET estado = 'cancelado'
WHERE id = $1
  AND barberia_id = $2
`

type CancelTurnoParams struct {
	ID         int32 `json:"id"`
	BarberiaID int32 `json:"barberia_id"`
}

func (q *Queries) CancelTurno(ctx context.Context, arg CancelTurnoParams) error {
	_, err := q.db.ExecContext(ctx, cancelTurno, arg.ID, arg.BarberiaID)
	return err
}

const createTurno = `-- name: CreateTurno :one
INSERT INTO turnos (
  barberia_id,
  barbero_id,
  servicio_id,
  fecha,
  hora_inicio,
  hora_fin,
  cliente_nombre,
  cliente_telefono,
  estado
)
VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, barberia_id, barbero_id, servicio_id, fecha, hora_inicio, hora_fin, cliente_nombre, cliente_telefono, estado, creado_en
`

type CreateTurnoParams struct {
	BarberiaID      int32          `json:"barberia_id"`
	BarberoID       int32          `json:"barbero_id"`
	ServicioID      int32          `json:"servicio_id"`
	Fecha           time.Time      `json:"fecha"`
	HoraInicio      time.Time      `json:"hora_inicio"`
	HoraFin         time.Time      `json:"hora_fin"`
	ClienteNombre   string         `json:"cliente_nombre"`
	ClienteTelefono sql.NullString `json:"cliente_telefono"`
	Estado          sql.NullString `json:"estado"`
}

func (q *Queries) CreateTurno(ctx context.Context, arg CreateTurnoParams) (Turno, error) {
	row := q.db.QueryRowContext(ctx, createTurno,
		arg.BarberiaID,
		arg.BarberoID,
		arg.ServicioID,
		arg.Fecha,
		arg.HoraInicio,
		arg.HoraFin,
		arg.ClienteNombre,
		arg.ClienteTelefono,
		arg.Estado,
	)
	var i Turno
	err := row.Scan(
		&i.ID,
		&i.BarberiaID,
		&i.BarberoID,
		&i.ServicioID,
		&i.Fecha,
		&i.HoraInicio,
		&i.HoraFin,
		&i.ClienteNombre,
		&i.ClienteTelefono,
		&i.Estado,
		&i.CreadoEn,
	)
	return i, err
}

const hasTurnoOverlap = `-- name: HasTurnoOverlap :one
SELECT EXISTS (
  SELECT 1
  FROM turnos
  WHERE barberia_id = $1
    AND barbero_id = $2
    AND fecha = $3
    AND estado != 'cancelado'
    AND (
      hora_inicio < $5
      AND hora_fin > $4
    )
)
`

type HasTurnoOverlapParams struct {
	BarberiaID int32     `json:"barberia_id"`
	BarberoID  int32     `json:"barbero_id"`
	Fecha      time.Time `json:"fecha"`
	HoraFin    time.Time `json:"hora_fin"`
	HoraInicio time.Time `json:"hora_inicio"`
}

func (q *Queries) HasTurnoOverlap(ctx context.Context, arg HasTurnoOverlapParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasTurnoOverlap,
		arg.BarberiaID,
		arg.BarberoID,
		arg.Fecha,
		arg.HoraFin,
		arg.HoraInicio,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listTurnosByFecha = `-- name: ListTurnosByFecha :many
SELECT t.id, t.barberia_id, t.barbero_id, t.servicio_id, t.fecha, t.hora_inicio, t.hora_fin, t.cliente_nombre, t.cliente_telefono, t.estado, t.creado_en, s.nombre AS servicio_nombre, u.nombre AS barbero_nombre
FROM turnos t
JOIN servicios s ON s.id = t.servicio_id
JOIN usuarios u ON u.id = t.barbero_id
WHERE t.barberia_id = $1
  AND t.fecha = $2
  AND t.estado != 'cancelado'
ORDER BY t.hora_inicio
`

type ListTurnosByFechaParams struct {
	BarberiaID int32     `json:"barberia_id"`
	Fecha      time.Time `json:"fecha"`
}

type ListTurnosByFechaRow struct {
	ID              int32          `json:"id"`
	BarberiaID      int32          `json:"barberia_id"`
	BarberoID       int32          `json:"barbero_id"`
	ServicioID      int32          `json:"servicio_id"`
	Fecha           time.Time      `json:"fecha"`
	HoraInicio      time.Time      `json:"hora_inicio"`
	HoraFin         time.Time      `json:"hora_fin"`
	ClienteNombre   string         `json:"cliente_nombre"`
	ClienteTelefono sql.NullString `json:"cliente_telefono"`
	Estado          sql.NullString `json:"estado"`
	CreadoEn        sql.NullTime   `json:"creado_en"`
	ServicioNombre  string         `json:"servicio_nombre"`
	BarberoNombre   string         `json:"barbero_nombre"`
}

func (q *Queries) ListTurnosByFecha(ctx context.Context, arg ListTurnosByFechaParams) ([]ListTurnosByFechaRow, error) {
	rows, err := q.db.QueryContext(ctx, listTurnosByFecha, arg.BarberiaID, arg.Fecha)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTurnosByFechaRow
	for rows.Next() {
		var i ListTurnosByFechaRow
		if err := rows.Scan(
			&i.ID,
			&i.BarberiaID,
			&i.BarberoID,
			&i.ServicioID,
			&i.Fecha,
			&i.HoraInicio,
			&i.HoraFin,
			&i.ClienteNombre,
			&i.ClienteTelefono,
			&i.Estado,
			&i.CreadoEn,
			&i.ServicioNombre,
			&i.BarberoNombre,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTurnosByFechaAndBarbero = `-- name: ListTurnosByFechaAndBarbero :many
SELECT t.id, t.barberia_id, t.barbero_id, t.servicio_id, t.fecha, t.hora_inicio, t.hora_fin, t.cliente_nombre, t.cliente_telefono, t.estado, t.creado_en, s.nombre AS servicio_nombre
FROM turnos t
JOIN servicios s ON s.id = t.servicio_id
WHERE t.barberia_id = $1
  AND t.fecha = $2
  AND t.barbero_id = $3
  AND t.estado != 'cancelado'
ORDER BY t.hora_inicio
`

type ListTurnosByFechaAndBarberoParams struct {
	BarberiaID int32     `json:"barberia_id"`
	Fecha      time.Time `json:"fecha"`
	BarberoID  int32     `json:"barbero_id"`
}

type ListTurnosByFechaAndBarberoRow struct {
	ID              int32          `json:"id"`
	BarberiaID      int32          `json:"barberia_id"`
	BarberoID       int32          `json:"barbero_id"`
	ServicioID      int32          `json:"servicio_id"`
	Fecha           time.Time      `json:"fecha"`
	HoraInicio      time.Time      `json:"hora_inicio"`
	HoraFin         time.Time      `json:"hora_fin"`
	ClienteNombre   string         `json:"cliente_nombre"`
	ClienteTelefono sql.NullString `json:"cliente_telefono"`
	Estado          sql.NullString `json:"estado"`
	CreadoEn        sql.NullTime   `json:"creado_en"`
	ServicioNombre  string         `json:"servicio_nombre"`
}

func (q *Queries) ListTurnosByFechaAndBarbero(ctx context.Context, arg ListTurnosByFechaAndBarberoParams) ([]ListTurnosByFechaAndBarberoRow, error) {
	rows, err := q.db.QueryContext(ctx, listTurnosByFechaAndBarbero, arg.BarberiaID, arg.Fecha, arg.BarberoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTurnosByFechaAndBarberoRow
	for rows.Next() {
		var i ListTurnosByFechaAndBarberoRow
		if err := rows.Scan(
			&i.ID,
			&i.BarberiaID,
			&i.BarberoID,
			&i.ServicioID,
			&i.Fecha,
			&i.HoraInicio,
			&i.HoraFin,
			&i.ClienteNombre,
			&i.ClienteTelefono,
			&i.Estado,
			&i.CreadoEn,
			&i.ServicioNombre,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTurnosOcupados = `-- name: ListTurnosOcupados :many
SELECT barbero_id, hora_inicio, hora_fin
FROM turnos
WHERE barberia_id = $1
  AND fecha = $2
  AND estado != 'cancelado'
ORDER BY hora_inicio
`

type ListTurnosOcupadosParams struct {
	BarberiaID int32     `json:"barberia_id"`
	Fecha      time.Time `json:"fecha"`
}

type ListTurnosOcupadosRow struct {
	BarberoID  int32     `json:"barbero_id"`
	HoraInicio time.Time `json:"hora_inicio"`
	HoraFin    time.Time `json:"hora_fin"`
}

func (q *Queries) ListTurnosOcupados(ctx context.Context, arg ListTurnosOcupadosParams) ([]ListTurnosOcupadosRow, error) {
	rows, err := q.db.QueryContext(ctx, listTurnosOcupados, arg.BarberiaID, arg.Fecha)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTurnosOcupadosRow
	for rows.Next() {
		var i ListTurnosOcupadosRow
		if err := rows.Scan(&i.BarberoID, &i.HoraInicio, &i.HoraFin); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
